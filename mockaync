#include <uwebsockets/App.h>
#include <folly/init/Init.h>
#include <folly/executors/CPUThreadPoolExecutor.h>
#include <folly/futures/Future.h>
#include <iostream>

int main(int argc, char *argv[]) {
    folly::Init init(&argc, &argv);

    auto executor = std::make_shared<folly::CPUThreadPoolExecutor>(16);

    uWS::App()
            .get("/async_print", [executor](auto *res, auto *req) {
                auto res_ptr = std::shared_ptr<uWS::HttpResponse<false> >(res, [](auto *) {
                });
                auto aborted = std::make_shared<std::atomic<bool> >(false);

                res->onAborted([aborted]() {
                    aborted->store(true, std::memory_order_release);
                    std::cout << "Request aborted by client\n";
                });
                folly::via(executor.get())
                        .thenValue([=](folly::Unit) {
                            // std::cout << "Async start, token=" << token << ", path=" << path << std::endl;
                            std::this_thread::sleep_for(std::chrono::milliseconds(10));
                            std::cout << "Async task end" << std::endl;
                            return folly::unit;
                        })
                        .thenValue([=](folly::Unit) {
                            std::cout << "Response end" << std::endl;
                            if (!aborted->load(std::memory_order_acquire)) {
                                res_ptr->end("async print");
                            } else {
                                std::cout << "Client already aborted, skip res->end()\n";
                            }
                        })
                        .thenError(folly::tag_t<folly::exception_wrapper>{},
                                   [res_ptr, aborted](const folly::exception_wrapper &ew) {
                                       std::cerr << "Async error: " << ew.what() << std::endl;
                                       if (!aborted->load(std::memory_order_acquire)) {
                                           res_ptr->writeStatus("500 Internal Server Error");
                                           res_ptr->end("error");
                                       } else {
                                           std::cout << "Client already aborted, skip error response\n";
                                       }
                                   });
            })
            .listen(9001, [](auto *token) {
                if (token) {
                    std::cout << "Server listening on port 9001\n";
                } else {
                    std::cerr << "Failed to listen on port 9001\n";
                }
            })
            .run();

    return 0;
}
